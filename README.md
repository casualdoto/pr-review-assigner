# PR Reviewer Assignment Service

## Вопросы и архитектурные решения

### 1. Эндпоинт для автоматического назначения ревьюверов после создания PR

**Проблема:** Если в момент создания PR не было доступных ревьюверов (например, все члены команды были неактивны), PR остается без ревьюверов. Как назначить их позже?

**Решение:** Добавлен эндпоинт `POST /pullRequest/assignReviewers` для автоматического назначения или дополнения ревьюверов.

**Алгоритм работы:**
1. Если уже назначено 2 ревьювера → ничего не делает, возвращает PR без изменений
2. Если назначен 1 ревьювер → добавляет второго из активных членов команды автора
3. Если нет ревьюверов → назначает до 2 активных членов команды автора
4. Исключаются: автор PR, уже назначенные ревьюверы
5. Нельзя назначать ревьюверов для MERGED PR (возвращается ошибка `PR_MERGED`)

**Преимущества:**
- Решает проблему "забытых" PR без ревьюверов
- Позволяет дополнить ревьюверов когда появились новые активные члены команды

---

### 2. Автоматическое переназначение PR при деактивации пользователя

**Проблема:** Что делать с открытыми PR, где деактивированный пользователь является ревьювером?

**Решение:** При деактивации пользователя (установка `isActive = false`) система автоматически переназначает все открытые PR.

**Алгоритм работы:**
1. Находятся все OPEN PR, где пользователь является ревьювером
2. Для каждого PR происходит поиск активного кандидата из той же команды
3. Исключаются: автор PR, уже назначенные ревьюверы, деактивируемый пользователь
4. Если найден подходящий кандидат - происходит переназначение
5. Если кандидатов нет - ревьювер просто удаляется из PR

**Преимущества:**
- Не остаётся зависших PR с неактивными ревьюверами
- Автоматизация снижает необходимость ручного управления

Операция деактивации пользователя всегда успешна, даже если переназначение PR не удалось (ошибки логируются).

---

### 3. Исправление названия поля в эндпоинте /pullRequest/reassign

**Проблема:** В исходной спецификации `openapi.yml` для эндпоинта `/pullRequest/reassign` было несоответствие:
- Схема определяла поле `old_user_id`
- Пример показывал поле `old_reviewer_id`

Это создавало путаницу - генератор кода создавал структуры согласно схеме, но примеры показывали другое название.

**Решение:** Смена названия поля на `old_reviewer_id` как в схеме, так и в примере.

---

### 4. Противоречие в спецификации OpenAPI для эндпоинта /team/add

**Проблема:** Эндпоинт `/team/add` описан как "создаёт/обновляет пользователей", но возвращает ошибку 400 `TEAM_EXISTS`, если команда уже существует. Если эндпоинт подразумевает возможность обновления, почему существование команды - ошибка?

**Решение:** Разделена ответственность между двумя эндпоинтами:

- **`/team/add` (POST)** - строго создание новой команды
  - Если команда уже существует → ошибка 400 `TEAM_EXISTS`
  
- **`/team/update` (POST)** - добавление/обновление участников в существующей команде
  - Если команда не найдена → ошибка 404 `NOT_FOUND`

**Преимущества подхода:**
1. Устраняет противоречие в API
2. Делает операции более явными и предсказуемыми
3. Соответствует принципу единственной ответственности (SOLID)
4. Улучшает читаемость и понимание API

---

### 5. Swagger UI для тестирования API

**Вопрос:** Требуется ли добавить Swagger UI для удобного тестирования API?

**Решение:** Добавлен контейнер Swagger UI, доступный на порту `8081` (http://localhost:8081).

**Возможности:**
- Просмотр документации всех endpoint'ов
- Выполнение тестовых запросов прямо из браузера
- Проверка форматов запросов/ответов
- Интерактивное изучение API

**Реализация:**
1. Добавление сервиса `swagger-ui` в `docker-compose.yml`
2. Монтирование файла `docs/openapi.yml` в контейнер Swagger UI
3. Добавление эндпоинта `GET /openapi.yml` в основное приложение
4. Настройка секции `servers` в OpenAPI схеме
5. Добавление CORS middleware для разрешения запросов от Swagger UI к API

---

## Выполненные дополнительные задания

### 1. Эндпоинт статистики 

Реализован эндпоинт `GET /statistics`, который возвращает количество назначений на ревью для каждого пользователя.

**Возвращаемые данные:**
- `user_id` - идентификатор пользователя
- `username` - имя пользователя  
- `assignments_count` - количество раз, когда пользователь был назначен ревьювером

Статистика сортируется по убыванию количества назначений, затем по имени пользователя.

### 2. Массовая деактивация пользователей команды

Реализован эндпоинт `POST /team/deactivateUsers` для массовой деактивации пользователей команды с автоматическим переназначением открытых PR.

**Алгоритм работы:**
1. Валидация: проверяется существование команды и что все указанные пользователи принадлежат ей
2. Получение всех открытых PR деактивируемых пользователей одним запросом
3. Подготовка плана переназначений в памяти (без дополнительных запросов к БД)
4. Выполнение массовой деактивации и переназначения в одной транзакции

**Оптимизация производительности:**
- Batch-операции: массовая деактивация через `UPDATE ... WHERE user_id = ANY($1)`
- Получение открытых PR одним запросом через `WHERE user_id = ANY($1) AND status = 'OPEN'`
- Подготовка плана переназначений в памяти (O(n*m), где n - количество PR, m - активных кандидатов)
- Batch-переназначение всех PR в одной транзакции
- Минимизация числа запросов к БД: ~4 запроса независимо от объема данных

**Возвращаемые данные:**
- `deactivated_users` - список деактивированных пользователей
- `reassigned_prs_count` - количество переназначенных PR (не PR, а назначений ревьюверов)