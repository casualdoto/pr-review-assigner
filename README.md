# PR Reviewer Assignment Service

Микросервис для автоматического назначения ревьюеров на Pull Request'ы с управлением командами и участниками.

## Быстрый старт

### С использованием Make

```bash
# 1. Собрать Docker образы
make build

# 2. Запустить все сервисы
make up

# 3. Проверить статус
make ps
```

### Запуск без Make

```powershell
# 1. Собрать Docker образы
docker-compose build

# 2. Запустить все сервисы
docker-compose up -d

# 3. Проверить статус
docker-compose ps
```

После успешного запуска сервис будет доступен:
- **API**: http://localhost:8080
- **Swagger UI**: http://localhost:8081
- **PostgreSQL**: localhost:5432

## Доступные команды Makefile

| Команда | Описание |
|---------|----------|
| `make help` | Показать справку по всем доступным командам |
| `make build` | Собрать Docker образы |
| `make up` | Запустить все сервисы (БД, миграции, приложение, Swagger UI) |
| `make down` | Остановить все сервисы |
| `make restart` | Перезапустить сервисы |
| `make logs` | Показать логи приложения (с отслеживанием новых) |
| `make logs-all` | Показать логи всех сервисов |
| `make test` | Запустить unit-тесты локально |
| `make clean` | Полная очистка (контейнеры, образы, volumes) |
| `make migrate-up` | Применить миграции вручную |
| `make migrate-down` | Откатить последнюю миграцию |
| `make ps` | Показать статус контейнеров |

### Примеры использования

```bash
# Посмотреть логи приложения в реальном времени
make logs

# Пересобрать и перезапустить после изменений
make build && make restart

# Полная очистка и новый запуск
make clean && make build && make up

# Запуск тестов локально (требуется установленный Go)
make test
```

## Тестирование API

### Через Swagger UI (рекомендуется)

1. Откройте http://localhost:8081 в браузере
2. Выберите сервер `http://localhost:8080`
3. Используйте интерактивный интерфейс для выполнения запросов

### Через curl (примеры некоторых запросов)

**Создание пользователя:**
```powershell
curl -X POST http://localhost:8080/user/add `
  -H "Content-Type: application/json" `
  -d '{\"user_id\": \"user1\", \"username\": \"Alice\", \"isActive\": true}'
```

**Создание команды:**
```powershell
curl -X POST http://localhost:8080/team/add `
  -H "Content-Type: application/json" `
  -d '{\"team_name\": \"backend\", \"members\": [{\"user_id\": \"user1\", \"username\": \"Alice\", \"isActive\": true}]}'
```

**Создание PR:**
```powershell
curl -X POST http://localhost:8080/pullRequest/add `
  -H "Content-Type: application/json" `
  -d '{\"pr_id\": \"pr1\", \"title\": \"Feature X\", \"author_id\": \"user1\"}'
```

**Получение статистики:**
```powershell
curl http://localhost:8080/statistics
```

## Архитектура

### Структура проекта
```
pr-review-assigner/
├── cmd/server/          # Точка входа приложения
├── internal/
│   ├── api/            # Генерированный код из OpenAPI
│   ├── config/         # Конфигурация приложения
│   ├── handler/        # HTTP обработчики
│   ├── service/        # Бизнес-логика
│   └── storage/        # Работа с БД
├── migrations/         # Миграции базы данных
├── docs/              # OpenAPI спецификация
├── docker-compose.yml # Конфигурация Docker Compose
├── Dockerfile         # Сборка приложения
└── Makefile          # Команды для управления проектом
```

### Технологический стек
- **Язык**: Go 1.25
- **База данных**: PostgreSQL 15
- **Миграции**: golang-migrate
- **API документация**: OpenAPI 3.0 + Swagger UI
- **Контейнеризация**: Docker + Docker Compose

## Остановка и очистка

```bash
# Остановить сервисы
make down

# Полная очистка (удаление контейнеров, образов, volumes)
make clean
```

Без Make:
```powershell
# Остановить сервисы
docker-compose down

# Полная очистка
docker-compose down -v --rmi all --remove-orphans
```

---

## Вопросы и архитектурные решения

### 1. Эндпоинт для автоматического назначения ревьюверов после создания PR

**Проблема:** Если в момент создания PR не было доступных ревьюверов (например, все члены команды были неактивны), PR остается без ревьюверов. Как назначить их позже?

**Решение:** Добавлен эндпоинт `POST /pullRequest/assignReviewers` для автоматического назначения или дополнения ревьюверов.

**Алгоритм работы:**
1. Если уже назначено 2 ревьювера → ничего не делает, возвращает PR без изменений
2. Если назначен 1 ревьювер → добавляет второго из активных членов команды автора
3. Если нет ревьюверов → назначает до 2 активных членов команды автора
4. Исключаются: автор PR, уже назначенные ревьюверы
5. Нельзя назначать ревьюверов для MERGED PR (возвращается ошибка `PR_MERGED`)

**Преимущества:**
- Решает проблему "забытых" PR без ревьюверов
- Позволяет дополнить ревьюверов когда появились новые активные члены команды

---

### 2. Автоматическое переназначение PR при деактивации пользователя

**Проблема:** Что делать с открытыми PR, где деактивированный пользователь является ревьювером?

**Решение:** При деактивации пользователя (установка `isActive = false`) система автоматически переназначает все открытые PR.

**Алгоритм работы:**
1. Находятся все OPEN PR, где пользователь является ревьювером
2. Для каждого PR происходит поиск активного кандидата из той же команды
3. Исключаются: автор PR, уже назначенные ревьюверы, деактивируемый пользователь
4. Если найден подходящий кандидат - происходит переназначение
5. Если кандидатов нет - ревьювер просто удаляется из PR

**Преимущества:**
- Не остаётся зависших PR с неактивными ревьюверами
- Автоматизация снижает необходимость ручного управления

Операция деактивации пользователя всегда успешна, даже если переназначение PR не удалось (ошибки логируются).

---

### 3. Исправление названия поля в эндпоинте /pullRequest/reassign

**Проблема:** В исходной спецификации `openapi.yml` для эндпоинта `/pullRequest/reassign` было несоответствие:
- Схема определяла поле `old_user_id`
- Пример показывал поле `old_reviewer_id`

Это создавало путаницу - генератор кода создавал структуры согласно схеме, но примеры показывали другое название.

**Решение:** Смена названия поля на `old_reviewer_id` как в схеме, так и в примере.

---

### 4. Противоречие в спецификации OpenAPI для эндпоинта /team/add

**Проблема:** Эндпоинт `/team/add` описан как "создаёт/обновляет пользователей", но возвращает ошибку 400 `TEAM_EXISTS`, если команда уже существует. Если эндпоинт подразумевает возможность обновления, почему существование команды - ошибка?

**Решение:** Разделена ответственность между двумя эндпоинтами:

- **`/team/add` (POST)** - строго создание новой команды
  - Если команда уже существует → ошибка 400 `TEAM_EXISTS`
  
- **`/team/update` (POST)** - добавление/обновление участников в существующей команде
  - Если команда не найдена → ошибка 404 `NOT_FOUND`

**Преимущества подхода:**
1. Устраняет противоречие в API
2. Делает операции более явными и предсказуемыми
3. Соответствует принципу единственной ответственности (SOLID)
4. Улучшает читаемость и понимание API

---

### 5. Swagger UI для тестирования API

**Вопрос:** Требуется ли добавить Swagger UI для удобного тестирования API?

**Решение:** Добавлен контейнер Swagger UI, доступный на порту `8081` (http://localhost:8081).

**Возможности:**
- Просмотр документации всех endpoint'ов
- Выполнение тестовых запросов прямо из браузера
- Проверка форматов запросов/ответов
- Интерактивное изучение API

**Реализация:**
1. Добавление сервиса `swagger-ui` в `docker-compose.yml`
2. Монтирование файла `docs/openapi.yml` в контейнер Swagger UI
3. Добавление эндпоинта `GET /openapi.yml` в основное приложение
4. Настройка секции `servers` в OpenAPI схеме
5. Добавление CORS middleware для разрешения запросов от Swagger UI к API

---

## Выполненные дополнительные задания

### 1. Эндпоинт статистики 

Реализован эндпоинт `GET /statistics`, который возвращает количество назначений на ревью для каждого пользователя.

**Возвращаемые данные:**
- `user_id` - идентификатор пользователя
- `username` - имя пользователя  
- `assignments_count` - количество раз, когда пользователь был назначен ревьювером

Статистика сортируется по убыванию количества назначений, затем по имени пользователя.

### 2. Массовая деактивация пользователей команды

Реализован эндпоинт `POST /team/deactivateUsers` для массовой деактивации пользователей команды с автоматическим переназначением открытых PR.

**Алгоритм работы:**
1. Валидация: проверяется существование команды и что все указанные пользователи принадлежат ей
2. Получение всех открытых PR деактивируемых пользователей одним запросом
3. Подготовка плана переназначений в памяти (без дополнительных запросов к БД)
4. Выполнение массовой деактивации и переназначения в одной транзакции

**Оптимизация производительности:**
- Batch-операции: массовая деактивация через `UPDATE ... WHERE user_id = ANY($1)`
- Получение открытых PR одним запросом через `WHERE user_id = ANY($1) AND status = 'OPEN'`
- Подготовка плана переназначений в памяти (O(n*m), где n - количество PR, m - активных кандидатов)
- Batch-переназначение всех PR в одной транзакции
- Минимизация числа запросов к БД: ~4 запроса независимо от объема данных

**Возвращаемые данные:**
- `deactivated_users` - список деактивированных пользователей
- `reassigned_prs_count` - количество переназначенных PR (не PR, а назначений ревьюверов)